<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>编程珠玑第一章习题</title>
    <url>/2020/10/31/Programming_Pearls_01/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><blockquote>
<p>如果不缺内存，如何使用一个具有库的语言实现一种排序算法以表示和排序集合？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; i)&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j: S)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><blockquote>
<p>如何使用为逻辑运算（如与、或、移位）来实现位向量？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i] != <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i] &amp;= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i] &amp; <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><blockquote>
<p>运行时效率是设计目标的一个重要组成部分，所得到的的程序余姚足够高效。在你自己的系统上设计实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题1中排序的运行时间相比如何？假设n为10000000，且输入文件包含1000000个整数。</p>
</blockquote>
]]></content>
      <categories>
        <category>编程珠玑</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>编程学习路线</title>
    <url>/2020/11/25/code_requirement/</url>
    <content><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>大概从2012年开始，计算机技术突然在中国蓬勃发展起来。这一期间大量的互联网公司出现在人们的视野中，包括百度，腾讯，阿里巴巴等老牌互联网厂商，和字节跳动，美团，拼多多，滴滴等新星。互联网公司开始融入中国人的生活，并改变着中国人的生活。互联网行业的高薪也在吸引越来越多的大学生们毕业后就职于互联网公司，由此掀起了一股互联网就业热潮。今天，我们就来聊聊如何学习编程？</p>
<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><p>首先你得有一台可以编程的电脑。小屏的手机和传统的笔记远远不能满足一个合格的程序员编程的要求。如果你的资金有限，那么我建议你购买一台配置不低于下列条件的笔记本：  </p>
<blockquote>
<p>内存 &gt;= 8GB<br>SSD固态硬盘 &gt;= 256GB<br>处理器intel i5及以上</p>
</blockquote>
<p>如果你的资金充裕，我建议你购买macbook air或者macbook pro。似乎macbook天生就是为编程而生。相信我，你在这儿的投资永远是超值的！</p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>待续   </p>
<h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>onenote笔记<br>leetcode刷题<br>牛客网面经<br>待续   </p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo + Next + GitHub + Gitalk</title>
    <url>/2020/10/31/hexo_next_github_gitalk/</url>
    <content><![CDATA[<p>本文主要介绍Hexo + Next在GitHub上自动部署教程。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><blockquote>
<p>一个轻量级的静态博客框架，方便灵活，深受程序员喜爱。</p>
</blockquote>
<h3 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h3><blockquote>
<p>Hexo的一款主题，简介美观。</p>
</blockquote>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h3><blockquote>
<p>世界上最大开源项目托管空间，本文借助GitHub托管<a href="https://blog.hoobo.net/">本博客</a>的源代码，利用GitHub Pages托管博客网页，使用GitHub Actions实现博客的自动部署。</p>
</blockquote>
<h3 id="gitalk"><a href="#gitalk" class="headerlink" title="gitalk"></a>gitalk</h3><blockquote>
<p>一款评论系统插件，它是基于GitHub issue实现的。优点是免费，无限空间。缺点是，每一篇博客都需要作者登陆GitHub开启一个新的issue。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Github创建博客仓库"><a href="#Github创建博客仓库" class="headerlink" title="Github创建博客仓库"></a>Github创建博客仓库</h3><ul>
<li>登陆GitHub，创建名为username.github.io的仓库。同时创建两个分支，第一个<code>source</code>，用于保存源代码，同时设为主分支；第二个分支名为<code>master</code>，用于托管博客网页。</li>
<li>找到Settings &gt; github pages。选择branch为<code>master</code>。custom domain里填入自己的域名，例如‘blog.hoobo.net’。此时source分支里应该多了一个‘CNAME’文件。<br><img src="/images/posts/hexo_next_githu_gitalk01.png"></li>
<li>点击Actions，创建一个新的文件pages.yml，并用下面的代码代替默认代码<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">source</span>  <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">12.</span><span class="string">x</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12.x&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">master</span>  <span class="comment"># deploying branch</span></span><br></pre></td></tr></table></figure></li>
<li>clone仓库到本地名为Blog的文件夹</li>
</ul>
<h3 id="本地仓库下载和配置"><a href="#本地仓库下载和配置" class="headerlink" title="本地仓库下载和配置"></a>本地仓库下载和配置</h3><ul>
<li>安装node.js和git</li>
<li>参考<a href="https://hexo.io/zh-cn/docs/">文档</a>安装hexo并初始化</li>
<li>将‘CNAME’文件移入source文件夹，为了可以使用自定义域名</li>
<li>使用npm安装next主题<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo-site</span><br><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure></li>
<li>修改next主题的配置文件。为了避免修改hexo-theme-next包，从<code>./node_modules/hexo-theme-next/_config.yml</code>拷贝到<code>./_config.next.yml</code>并参照本博客的<a href="https://github.com/SonpKing/sonpking.github.io/blob/source/_config.next.yml">_config.next.yml</a>修改。</li>
<li>参照本博客的<a href="https://github.com/SonpKing/sonpking.github.io/blob/source/_config.yml">_config.yml</a>修改hexo配置文件<code>./_config.yml</code>。<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://blog.hoobo.net</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Gitalk评论系统配置"><a href="#Gitalk评论系统配置" class="headerlink" title="Gitalk评论系统配置"></a>Gitalk评论系统配置</h3><ul>
<li>在GitHub上找到Settings Developer &gt; settings &gt; OAuth Apps &gt; New OAuth App新建一个Application</li>
<li>找到新建Application的Client ID和Client secret，修改配置文件_config.next.yml<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">github_id:</span> <span class="string">SonpKing</span> <span class="comment"># GitHub repo owner</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">sonpking.github.io</span> <span class="comment"># Repository name to store issues</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="string">xxxx</span> <span class="comment"># GitHub Application Client ID</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="string">xxxx</span> <span class="comment"># GitHub Application Client Secret</span></span><br><span class="line">  <span class="attr">admin_user:</span> [<span class="string">SonpKing</span>]</span><br><span class="line">  <span class="attr">distraction_free_mode:</span> <span class="literal">true</span> <span class="comment"># Facebook-like distraction free mode</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="推送本地分支到远程分支"><a href="#推送本地分支到远程分支" class="headerlink" title="推送本地分支到远程分支"></a>推送本地分支到远程分支</h3><ul>
<li>运行命令，本地调试。浏览器打开localhost:4000，查看博客是够正常显示。<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li>
<li>将本地的source分支推送到远程的source分支，稍等1-3分钟，GitHub Actions将会自动部署。<br><img src="/images/posts/hexo_next_githu_gitalk02.png"></li>
<li>浏览器输入自定义域名，例如<code>blog.hoobo.net</code>。确认博客部署成功。</li>
</ul>
<h3 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h3><ul>
<li>在‘_post’文件夹下创建新的md文件</li>
<li>参考<code>推送本地分支到远程分支</code></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
  </entry>
  <entry>
    <title>VScode编写Latex文档</title>
    <url>/2020/11/27/latex_vscode/</url>
    <content><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>VScode &gt; 1.50<br>Tex Live 2020<br>VScode插件：Latex Workshop, Latex Utilities(用于统计字数)</p>
<h2 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h2><p>在项目根目录创建<code>.latexmkrc</code>文件用于<code>latexmk</code>命令，内容如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$out_dir</span>=<span class="string">&quot;./&quot;</span>;</span><br><span class="line"><span class="variable">$pdf_mode</span>=5;</span><br><span class="line"><span class="variable">$xelatex</span>=<span class="string">&quot;xelatex -outdir=out&quot;</span>;</span><br><span class="line"><span class="variable">$xdvipdfmx</span>=<span class="string">&quot;xdvipdfmx -q -E -o %D %O %S&quot;</span>;</span><br><span class="line"><span class="variable">$clean_ext</span> = <span class="string">&#x27;thm bbl hd loe synctex.gz xdv run.xml&#x27;</span>;</span><br><span class="line"><span class="variable">$makeindex</span> = <span class="string">&#x27;makeindex -s gind.ist %O -o %D %S&#x27;</span>;</span><br><span class="line">@default_files=(<span class="string">&#x27;zjuthesis.tex&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在vscode setting.json文件下添加下面的配置，用于配合workshop插件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;[latex]&quot;: &#123;</span><br><span class="line">    &quot;editor.formatOnPaste&quot;: false,</span><br><span class="line">    &quot;editor.suggestSelection&quot;: &quot;recentlyUsedByPrefix&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-pdf&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;pdflatex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span>,</span><br><span class="line">            <span class="string">&quot;%DOC%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;biber&quot;</span>, <span class="comment">//这里配置的是实际调用的包</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [] <span class="comment">//请不要加参数，因为在.latexmkrc文件中已经定义了参数</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [ //这里的选项会出现插件中，方便点击使用</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;latexmk&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xe-&gt;bib-&gt;xe-&gt;xe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;tools&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span>,</span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span>,</span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;editor.wordWrap&quot;: &quot;on&quot;, //编辑器自动换行</span><br></pre></td></tr></table></figure>

<h2 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h2><p>在tex文件中加上如下配置，就可以自动根据系统选择合适的字体了</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% ctex package stores one of &quot;windows&quot;, &quot;mac&quot;, and &quot;fandol&quot; in \g__ctex_fontset_tl</span></span><br><span class="line"><span class="keyword">\ifthenelse</span>&#123;<span class="keyword">\equal</span>&#123;<span class="keyword">\csname</span> g<span class="built_in">_</span><span class="built_in">_</span>ctex<span class="built_in">_</span>fontset<span class="built_in">_</span>tl<span class="keyword">\endcsname</span>&#125;&#123;windows&#125;&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">% Windows or other platform</span></span><br><span class="line">    <span class="keyword">\setCJKmainfont</span>[AutoFakeBold=&#123;<span class="keyword">\FakeBoldSize</span>&#125;]&#123;SimSun&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">\IfFileExists</span>&#123; /System/Library/Fonts/PingFang.ttc &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">% MacOS El Capitan and later version</span></span><br><span class="line">            <span class="comment">% https://github.com/CTeX-org/ctex-kit/issues/351</span></span><br><span class="line">            <span class="keyword">\setCJKmainfont</span>[BoldFont=&#123;Songti SC Bold&#125;]&#123;Songti SC Light&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">% Older MacOS</span></span><br><span class="line">            <span class="comment">% Fonts</span></span><br><span class="line">            <span class="keyword">\setCJKmainfont</span>[AutoFakeBold=&#123;<span class="keyword">\FakeBoldSize</span>&#125;]&#123;STSong&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在根目录运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">latexmk</span><br></pre></td></tr></table></figure>
<p>注意：配置保存在.latexmkrc。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在workshop插件中运行latexmk（约25s), 推荐！！！<br><img src="/images/posts/latex_vscode01.png"><br>或者分两步进行，在workshop插件中先运行xelatex编译主体（&lt;10s)，再运行xe-&gt;bib-&gt;xe-&gt;xe编译参考文献。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 103. 二叉树的锯齿形层序遍历</title>
    <url>/2020/12/22/leetcode_103/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题是层序遍历的变形，只需根据层数来判断每层的元素是从左到右还从右到左。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">zigzagLevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            que.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = que.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                TreeNode* t = que.front();</span><br><span class="line">                tmp.push_back(t-&gt;val);</span><br><span class="line">                que.pop();</span><br><span class="line">                <span class="keyword">if</span>(t -&gt; left)&#123;</span><br><span class="line">                    que.push(t -&gt; left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t -&gt; right)&#123;</span><br><span class="line">                    que.push(t -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res.size()%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                reverse(tmp.begin(), tmp.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 118. 杨辉三角</title>
    <url>/2020/12/06/leetcode_118/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 1370. 上升下降字符串</title>
    <url>/2020/11/25/leetcode_1370/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<p>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。<br>重复步骤 2 ，直到你没法从 s 中选择字符。<br>从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。<br>重复步骤 5 ，直到你没法从 s 中选择字符。<br>重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。<br>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s &#x3D; &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题意，每次在结果字符串后面追加一个先递增再递减的字符串。因为所有的字符都是小写字母，所以可以先统计26个字母的个数，然后按照从前到后和从后往前的顺序遍历，并重复直到剩余的字符串为空。假如某个字母的个数为0，那么跳过，否则将该字母加入到结果中并将该字母的个数减一。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: s)&#123;</span><br><span class="line">            ++cnt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(res.size() &lt; n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push_back(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">                    --cnt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    res.push_back(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">                    --cnt[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 164. 最大间距</title>
    <url>/2020/11/26/leetcode_164/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。<br><a href="https://leetcode-cn.com/problems/maximum-gap/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要找出两个数的最大差值，那么就需要对原数组排序。最常见的快速排序的时间复杂度为NlgN。注意到题目中数值的范围为32位整数，所以考虑使用基数排序，时间复杂度仅为kN。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>快排</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; res)&#123;</span><br><span class="line">                res = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基数排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        radix_sort(nums);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i<span class="number">-1</span>] &gt; res)&#123;</span><br><span class="line">                res = nums[i] - nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">radix_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="built_in">exp</span> = <span class="number">1</span>; <span class="comment">//最大的整数*10会越界，所以应当使用long long</span></span><br><span class="line">        <span class="keyword">int</span> maxv = *max_element(nums.begin(), nums.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">exp</span> &lt;= maxv)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">                cnt[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                ++cnt[(nums[i]/<span class="built_in">exp</span>)%<span class="number">10</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">                cnt[i] += cnt[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">                tmp[--cnt[(nums[i]/<span class="built_in">exp</span>)%<span class="number">10</span>]] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, tmp);</span><br><span class="line">            <span class="built_in">exp</span> *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 188. 买卖股票的最佳时机 IV</title>
    <url>/2020/12/28/leetcode_188/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>典型的动态规划的题目。每天的状态为2种，持有股票和不持有股票。持有股票的状态可能是当日没有进行交易（交易数==前日交易数），或者当日进行了交易（交易数==前日交易数+1）；不持有股票的状态相反。用一个长度为k+1的数组记录交易数为[0, k]是进行k次交易后持有和不持有股票的最大收益。考虑到k&gt;n相当于无限次交易，特殊考虑降低时间复杂度。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;&#123;&#125;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> solver1(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> solver2(k, prices);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solver1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp0 = <span class="number">0</span>, dp1 = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp0 = max(dp0, dp1 + prices[i]);</span><br><span class="line">            dp1 = max(dp1, dp0 - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solver2</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(k+<span class="number">1</span>, <span class="number">-1e9</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = k; j &gt;= <span class="number">1</span>; --j)&#123;</span><br><span class="line">                dp0[j] = max(dp0[j], dp1[j] + prices[i]);</span><br><span class="line">                dp1[j] = max(dp1[j], dp0[j<span class="number">-1</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;=k; ++j)&#123;</span><br><span class="line">            res = max(res, dp0[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>分类讨论</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 204. 计数质数</title>
    <url>/2020/12/03/leetcode_204/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 205. 同构字符串</title>
    <url>/2020/12/27/leetcode_205/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><a href="https://leetcode-cn.com/problems/isomorphic-strings/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题相当于判断能不能找到两个字符串之间的一个唯一的映射。利用字典可以保存历史结果，如果遇到新的字符则假如字典；如果是旧的字符，那么到字典里查询是否正确。主要两个不同的字符不能映射到同一个字符所以，需要一个集合保存已经被映射过的字符，避免重复映射。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n != t.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; table;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(table.find(s[i])!=table.end())&#123;</span><br><span class="line">                <span class="keyword">if</span>(table[s[i]]!=t[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(used.find(t[i])==used.end())&#123;</span><br><span class="line">                    table[s[i]] = t[i];</span><br><span class="line">                    used.insert(t[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 217. 存在重复元素</title>
    <url>/2020/12/13/leetcode_217/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 222. 完全二叉树的节点个数</title>
    <url>/2020/11/24/leetcode_222/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个完全二叉树，求出该树的节点个数。<br>说明：<br>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p>示例:</p>
<p>输入: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \  &#x2F;</span><br><span class="line">4  5 6</span><br></pre></td></tr></table></figure>
<p>输出: 6</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>完全二叉树的编号非常有规律，若父节点编号为N，那么左子节点的编号为2*N，右子节点的编号为2*N+1。我们的目标是找到树中所有节点的个数，如果根节点编号为1，那么我们要找的就是最后一个节点的编号。如何判断最后一个节点在左子树还是右子树呢？一个比较简单的方法是看左右子树树高，如果相等那么最后一个节点必然在右子树，否则在左子树。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recur(root, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">(TreeNode* root, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(root -&gt; left);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="keyword">return</span> recur(root -&gt; right, <span class="number">2</span>*num + <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recur(root -&gt; left, <span class="number">2</span>*num);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root)&#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            root = root -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>题解</tag>
        <tag>dfs</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 239. 滑动窗口最大值</title>
    <url>/2021/01/02/leetcode_239/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>用一个单调下降的栈保存窗口最大值。每当窗口向后移动一步，首先比较这个值和栈顶的值，如果比栈顶大那么则弹出栈顶元素，否则加入栈中。然后比较栈底的值和窗口左侧的值，如果相等则弹出栈底的值。虽然这里称做栈，其实包含的操作是双端队列的操作，所以选择C++库中的deque容器实现。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!que.empty() &amp;&amp; que.back() &lt; nums[i])&#123;</span><br><span class="line">                que.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            que.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                res.push_back(que.front());</span><br><span class="line">                <span class="keyword">if</span>(nums[i-k+<span class="number">1</span>] == que.front())&#123;</span><br><span class="line">                    que.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 321. 拼接最大数</title>
    <url>/2020/12/02/leetcode_321/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。</p>
<p><a href="https://leetcode-cn.com/problems/create-maximum-number/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果仅从一个数组中取出K个数并保持相对顺序不变，那么可以利用单调栈的思想。在满足个数的前提下，如果可以当前的数比栈顶大则更新栈顶。如何保证个数足够呢，需要用两个变量分别记录剩余的数字个数和需要数字个数。剩余个数在每一次循环后减1，需要的个数在入栈时减1，出栈时加1。现在来看两个数组的情况，我们把K个数拆分i和K-i，即在第一个数组中取i个数，第二个数组中取K-i个数。那么现在问题的关键是如何合并两个数组中得到的子序列。这里使用双指针的做法，比较两个指针当前指向数的大小，每次取大的那个指针更新。如果两指针指向的值相等，则继续比较后面的值。如果在比较的过程中一个数组遍历完了，则默认没有遍历完的数组更大。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res, tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = max(<span class="number">0</span>, k - m), maxi = min(n, k); i &lt;= maxi; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t1 = get_subseq(nums1, i);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t2 = get_subseq(nums2, k - i);</span><br><span class="line">            tmp = merge(t1, t2);</span><br><span class="line">            <span class="keyword">if</span>(cmp(tmp, res))&#123;</span><br><span class="line">                res.swap(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> j = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size(), m = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &gt; nums2[j])&#123;</span><br><span class="line">                res.push_back(nums1[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &lt; nums2[j])&#123;</span><br><span class="line">                res.push_back(nums2[j++]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp(nums1, nums2, i, j))&#123;</span><br><span class="line">                res.push_back(nums1[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(nums2[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            res.push_back(nums1[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; m)&#123;</span><br><span class="line">            res.push_back(nums2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">get_subseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> remain = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.empty() &amp;&amp; nums[i] &gt; stk.back() &amp;&amp; remain &gt; cnt)&#123;</span><br><span class="line">                stk.pop_back();</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               stk.push_back(nums[i]); </span><br><span class="line">               --cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            --remain;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>顺便复习一下字典序比较大小，本题暂不需要字典序这么严格的比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_dict</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> j = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = nums1.begin() + i;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it2 = nums2.begin() + j;</span><br><span class="line">    <span class="keyword">while</span>(it1 != nums2.end() &amp;&amp; it2 != nums1.end())&#123;</span><br><span class="line">        <span class="keyword">if</span>(it1 == nums1.end())&#123;</span><br><span class="line">            it1 = nums2.begin() + j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(it2 == nums2.end())&#123;</span><br><span class="line">            it2 = nums1.begin() + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*it1 &gt; *it2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*it1 &lt; *it2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++it1;</span><br><span class="line">        ++it2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/12/01/leetcode_34/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据题意，最直观的做法是从前往后遍历一遍。但是这种做法的平均时间复杂度为$O(n)$。在有序数组中查找的最快算法是二分法，参考库函数lower_bound()，我们定义一个找到第一个大于等于target的函数，这样就找到了左边界。再次利用这个函数找第一个大于等于target+1的函数，这样就找到了右边界，注意需要减一。二分法的时间复杂度为$O(lgN)$。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = lowerbound(nums, target);</span><br><span class="line">        <span class="keyword">int</span> end = lowerbound(nums, target + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(start == end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;start, end - <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowerbound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &gt;= target)&#123;</span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 376. 摆动序列</title>
    <url>/2020/12/12/leetcode_376/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 387. 字符串中的第一个唯一字符</title>
    <url>/2020/12/23/leetcode_387/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一遍统计每个字符出现的次数，第二遍判断谁是第一个只出现一次的字符，如果没有找到则返回-1.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: s)&#123;</span><br><span class="line">            ++cnt[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 435. 无重叠区间</title>
    <url>/2020/12/31/leetcode_435/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<p>可以认为区间的终点总是大于它的起点。<br>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。<br>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>每次优先选择最小末端的线段，过滤掉起始小于末端的那些线段</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; interval1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; interval2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  interval1[<span class="number">1</span>] &lt; interval2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last_ind = <span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&gt;=last_ind)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">                last_ind = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 454. 四数相加 II</title>
    <url>/2020/11/27/leetcode_454/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p><a href="https://leetcode-cn.com/problems/4sum-ii/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为只有4个数组，所以可以两两组成一组，此时时间复杂度已经为O(N^2)。利用字典我们可以在O(1)时间复杂度里，找到目标值。在本次中如果前两组数据的和为后两组数据和为M，那么我们需要在前两组的数据中找到和为-M的元组的个数，也就是说需要为前两组数据的枚举和做个数统计，并存放在字典中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                ++cnt[(A[i] + B[j])];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt.find(-(C[i] + D[j])) != cnt.end())&#123;</span><br><span class="line">                    res += cnt[-(C[i] + D[j])];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 49. 字母异位词分组</title>
    <url>/2020/12/14/leetcode_49/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题的关键是如何让异位词变成统一的格式，然后利用字典映射统计。异位词可以通过排序的方法得到一个唯一序列，也可统计各个字符的个数然后构建一个键值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="comment">//计数法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: str)&#123;</span><br><span class="line">                ++cnt[c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> ind = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> p: cnt)&#123;</span><br><span class="line">                ind += to_string(p.first) + to_string(p.second);</span><br><span class="line">            &#125;</span><br><span class="line">            maps[ind].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p: maps)&#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><span class="comment">//排序法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; maps;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> str: strs)&#123;</span><br><span class="line">            <span class="built_in">string</span> ind = str;</span><br><span class="line">            sort(ind.begin(), ind.end());</span><br><span class="line">            maps[ind].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p: maps)&#123;</span><br><span class="line">            res.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>字典</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 493. 翻转对</title>
    <url>/2020/11/28/leetcode_493/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p><a href="https://leetcode-cn.com/problems/reverse-pairs/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>本题和逆序对很相似，也可以使用归并算法的思想解决。不过在逆序对题中，统计逆序对的个数和merge的过程是放在一起的，而本题中需要先求翻转对的个数再排序。归并算法分为两步，第一步将原数组划分二等份，第二部合并。在合并过程中添加一些判断条件，就可以统计翻转对的个数。因为排序完成的那部分的翻转对的个数已经被统计过了，只需要关心未合并两部分之间存在的翻转对。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">aux</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        mergesort(nums, aux, <span class="number">0</span>, nums.size(), res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; aux, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> &amp;cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start + <span class="number">1</span> &gt;= end)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        mergesort(nums, aux, start, mid, cnt);</span><br><span class="line">        mergesort(nums, aux, mid, end, cnt);</span><br><span class="line">        <span class="keyword">int</span> i = start, j = mid;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)nums[i] &gt; <span class="number">2</span> * (<span class="keyword">long</span> <span class="keyword">long</span>)nums[j])&#123; <span class="comment">//2 * nums[j] out of the range of integer</span></span><br><span class="line">                cnt += mid - i; <span class="comment">//all index &gt; i will let nums[index] &gt; 2 * nums[j]</span></span><br><span class="line">                ++j;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i = start, j = mid;</span><br><span class="line">        <span class="keyword">int</span> t = start;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                aux[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                aux[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; mid)&#123;</span><br><span class="line">            aux[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; end)&#123;</span><br><span class="line">            aux[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(t = start; t &lt; end; ++t)&#123;</span><br><span class="line">            nums[t] = aux[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 605. 种花问题</title>
    <url>/2021/01/01/leetcode_605/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 1</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: flowerbed &#x3D; [1,0,0,0,1], n &#x3D; 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<blockquote>
<p>数组内已种好的花不会违反种植规则。<br>输入的数组长度范围为 [1, 20000]。<br>n 是非负整数，且不会超过输入数组的大小。</p>
</blockquote>
<p><a href="https://leetcode-cn.com/problems/can-place-flowers/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>尽可能地将花种植在靠近前面的位置，可以得出结论：两个1中间间隔3个0可以插入一盆花，间隔5个0可以插入两盆花…需要注意起始和末尾为0的情况，2个0就可以插入一盆花。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = flowerbed.size();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flowerbed[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res += (cnt - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += cnt / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res &gt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 62. 不同路径</title>
    <url>/2020/12/23/leetcode_62/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>动态规划的思想。每个格子到第一个格子的路径总数等于它上方的格子跟它左边的格子的和。因为只会用到左边的一个格子所以可以用一个一维数组替代二维的dp矩阵。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp[j] += dp[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 621. 任务调度器</title>
    <url>/2020/12/05/leetcode_621/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/task-scheduler/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 649. Dota2 参议院</title>
    <url>/2020/12/11/leetcode_649/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 659. 分割数组为连续子序列</title>
    <url>/2020/12/04/leetcode_659/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 738. 单调递增的数字</title>
    <url>/2020/12/15/leetcode_738/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 767. 重构字符串</title>
    <url>/2020/11/30/leetcode_767/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p><a href="https://leetcode-cn.com/problems/reorganize-string/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先统计每个字符出现的个数，然后维护一个优先队列按照字符的个数排序。每取一个字符则将它的个数减去一，如果个数为零则从优先队列中益处。当前被取用的字符在下次不能使用，保存在<code>last</code>变量里。最后判断得到的字符的长度是否和原字符长度相等，如果不想等则说明还有连续重复的字符未取尽。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reorganizeString</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: S)&#123;</span><br><span class="line">            ++cnt[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">pair</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; p: cnt)&#123;</span><br><span class="line">            que.push(<span class="built_in">make_pair</span>(p.second, p.first));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; last = &#123;<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line">        <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            tmp = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            res.push_back(tmp.second);</span><br><span class="line">            <span class="keyword">if</span>(--last.first &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                que.push(last);</span><br><span class="line">            &#125;</span><br><span class="line">            last = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.size() == S.size()? res: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 842. 将数组拆分成斐波那契序列</title>
    <url>/2020/12/08/leetcode_842/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 860. 柠檬水找零</title>
    <url>/2020/12/10/leetcode_860/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 861. 翻转矩阵后的得分</title>
    <url>/2020/12/07/leetcode_861/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://leetcode-cn.com/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>leetcode 976. 三角形的最大周长</title>
    <url>/2020/11/29/leetcode_976/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。</p>
<p>如果不能形成任何面积不为零的三角形，返回 0。</p>
<p><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">原题链接</a></p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>根据三角形的定义，任意两边之和大于第三边，两边之差小于第三边。利用三重循环，遍历每条边判断能否构成三角形并更新最大周长。此方法的时间复杂为O(n^3)。假如如果三角形三边是有序的，只要满足两小边只和大于第三边就行了。所以，我们可以先把所有长度由小到大排序，然后由后往前依次遍历找到第一个满足条件的三角形三边对的索引分别为ind, ind-1, ind-2。其中，ind为最大边，ind-2为最小边。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">2</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> A[i] + A[i - <span class="number">1</span>] + A[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>快排</tag>
      </tags>
  </entry>
</search>
